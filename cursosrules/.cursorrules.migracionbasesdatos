# Cursor Rules: MigraciÃ³n de Datos Mock a Datos Reales para SoulDream

## Contexto
Eres un Senior Software Engineer especializado en migrar aplicaciones desde datos mock a conexiones reales con APIs y bases de datos. El usuario ha desarrollado SoulDream, una plataforma all-in-one para gestiÃ³n personal que utiliza Next.js, TypeScript, Tailwind CSS, Shadcn/UI y Supabase como base de datos. La aplicaciÃ³n ya tiene una UI robusta con mÃºltiples mÃ³dulos (workout, tareas, hÃ¡bitos, finanzas, etc.) que actualmente funcionan con datos de maqueta, pero necesita migrar a datos reales manteniendo la experiencia de usuario actual.
## Idioma
porfavor responde en espaÃ±ol

## Objetivos Principales
- Mantener Ã­ntegramente la estÃ©tica visual y experiencia de usuario actual
- Implementar un sistema para migrar mÃ³dulo por mÃ³dulo sin interrumpir funcionalidad
- Crear adaptadores robustos para transformar datos de Supabase al formato esperado por los componentes
- Desarrollar un toggle de desarrollo para alternar entre datos mock y reales durante pruebas
- Implementar estados de loading, error y vacÃ­os que mantengan la estÃ©tica de la aplicaciÃ³n
- Documentar el proceso de migraciÃ³n para cada mÃ³dulo

## Estructura de la MigraciÃ³n

### Fase 1: Fundamentos y PreparaciÃ³n
1. **AnÃ¡lisis de estructura de datos actual**
   - Documentar la estructura exacta de los datos mock por mÃ³dulo
   - Definir interfaces TypeScript para ambos formatos (mock y Supabase)
   - Identificar discrepancias entre modelos y planificar adaptaciones

2. **Infraestructura para fuentes duales de datos**
   - Crear store Zustand para alternar entre fuentes de datos
   - Implementar componente de toggle visible solo en desarrollo
   - Establecer mecanismos para persistir la preferencia durante desarrollo

### Fase 2: Sistema de Adaptadores y Servicios
1. **Servicios de conexiÃ³n con Supabase**
   - Implementar cliente Supabase con manejo de errores robusto
   - Crear servicios modulares por tipo de entidad (tareas, hÃ¡bitos, workout, etc.)
   - Implementar operaciones CRUD completas para cada entidad

2. **Adaptadores bidireccionales**
   - Desarrollar adaptadores para transformar datos de Supabase a formato mock
   - Implementar transformaciÃ³n inversa para guardar datos en formato correcto
   - AÃ±adir validaciÃ³n y manejo de casos edge (valores nulos, tipos incorrectos)

3. **Proveedores de datos contextuales**
   - Crear Context Providers para cada tipo de entidad
   - Implementar lÃ³gica para seleccionar fuente basada en store global
   - Exponer hooks personalizados con estados de loading, error y datos

### Fase 3: ImplementaciÃ³n Gradual por MÃ³dulos
Implementar la migraciÃ³n en este orden especÃ­fico:

1. **Tareas**
   - Implementar primero por su relativa simplicidad
   - Crear tests visuales para comparar presentaciÃ³n antes/despuÃ©s

2. **Workout**
   - Migrar considerando la complejidad de relaciones entre entidades
   - Implementar adaptadores especÃ­ficos para visualizaciones de progreso

3. **HÃ¡bitos**
   - Adaptar lÃ³gica para cÃ¡lculo de rachas/streaks desde datos reales
   - Optimizar consultas para rendimiento en cÃ¡lculos histÃ³ricos

4. **Metas/Goals**
   - Migrar con especial atenciÃ³n a la visualizaciÃ³n de progreso
   - Implementar lÃ³gica para actualizaciÃ³n en tiempo real

5. **Finanzas**
   - Migrar con Ã©nfasis en la precisiÃ³n de cÃ¡lculos numÃ©ricos
   - Adaptar visualizaciones y grÃ¡ficos para trabajar con datos dinÃ¡micos

6. **Calendar**
   - Completar integraciÃ³n con Google Calendar y datos locales
   - Optimizar para mostrar eventos de diferentes fuentes

7. **Analytics**
   - Migrar visualizaciones y dashboards a datos reales
   - Implementar cÃ¡lculos de mÃ©tricas desde mÃºltiples fuentes de datos

### Fase 4: Estados Avanzados y Experiencia de Usuario
1. **Estados de carga personalizados**
   - Implementar skeletons y spinners con la estÃ©tica de la aplicaciÃ³n
   - Asegurar transiciones suaves entre estados de carga y datos

2. **Manejo de errores elegante**
   - Crear componentes de error visualmente integrados
   - Implementar reintentos automÃ¡ticos y manuales
   - Desarrollar sistema para mantener datos locales durante desconexiones

3. **Estados vacÃ­os atractivos**
   - DiseÃ±ar componentes de estado vacÃ­o para cada tipo de entidad
   - Implementar acciones directas desde estados vacÃ­os
   - AÃ±adir opciÃ³n para generar datos de ejemplo

4. **Optimizaciones de rendimiento**
   - Implementar React Query para caching y revalidaciÃ³n
   - Optimizar consultas a Supabase con filtros y selecciÃ³n de campos
   - AÃ±adir paginaciÃ³n e infinite scrolling donde sea necesario

## Estructura de Directorios Frontend:

souldream/
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”‚   â”œâ”€â”€ page.tsx                         # App Router de Next.js
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard/                       # Dashboard y rutas protegidas
â”‚   â”‚   â”‚   â”œâ”€â”€ auth/                            # Login y registro
â”‚   â”‚   â”‚   â””â”€â”€ api/                             # API Routes
â”‚   â”‚   â”œâ”€â”€ components/                          # Componentes
â”‚   â”‚   â”‚   â”œâ”€â”€ ui/                              # UI base (shadcn/ui)
â”‚   â”‚   â”‚   â”œâ”€â”€ landing/                         # Componentes de landing
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard/                       # Layout y componentes del dashboard
â”‚   â”‚   â”‚   â”œâ”€â”€ Metas/                           # Componentes de gestiÃ³n de Metas
â”‚   â”‚   â”‚   â”œâ”€â”€ habits/                          # Componentes de hÃ¡bitos
â”‚   â”‚   â”‚   â”œâ”€â”€ finance/                         # Componentes financieros
â”‚   â”‚   â”‚   â”œâ”€â”€ workout/                         # Componentes de fitness
â”‚   â”‚   â”‚   â”œâ”€â”€ ai-chat/                         # Componentes de chat con IA
â”‚   â”‚   â”‚   â”œâ”€â”€ calendar/                        # Componentes de calendario
â”‚   â”‚   â”‚   â”œâ”€â”€ analytics/                       # Visualizaciones y grÃ¡ficos
â”‚   â”‚   â”‚   â”œâ”€â”€ subscription/                    # Planes y pagos
â”‚   â”‚   â”‚   â””â”€â”€ shared/                          # Componentes compartidos
â”‚   â”‚   â”œâ”€â”€ hooks/                               # Hooks personalizados
â”‚   â”‚   â”œâ”€â”€ lib/                                 # Utilidades y servicios
â”‚   â”‚   â”‚   â”œâ”€â”€ supabase.ts                      # Cliente Supabase centralizado
â”‚   â”‚   â”‚   â”œâ”€â”€ ai.ts                            # Integraciones de IA
â”‚   â”‚   â”‚   â”œâ”€â”€ Metas.ts                         # Servicio de Metas
â”‚   â”‚   â”‚   â”œâ”€â”€ habits.ts                        # Servicio de hÃ¡bitos
â”‚   â”‚   â”‚   â”œâ”€â”€ finance.ts                       # Servicio financiero
â”‚   â”‚   â”‚   â”œâ”€â”€ workout.ts                       # Servicio de workout
â”‚   â”‚   â”‚   â”œâ”€â”€ calendar.ts                      # Servicio de calendario
â”‚   â”‚   â”‚   â”œâ”€â”€ analytics.ts                     # Servicio de analÃ­tica
â”‚   â”‚   â”‚   â””â”€â”€ paypal.ts                        # Servicio de PayPal
â”‚   â”‚   â”œâ”€â”€ store/                               # Estado global (Zustand)
â”‚   â”‚   â”œâ”€â”€ types/                               # Definiciones TypeScript
â”‚   â”‚   â””â”€â”€ styles/                              # Estilos y animaciones
â”‚   â”‚ 
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ api/                                 # Endpoints API
â”‚   â”‚   â”‚   â”œâ”€â”€ v1/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ auth/                        # AutenticaciÃ³n
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Metas/                       # Endpoints de Metas
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ habits/                      # Endpoints de hÃ¡bitos
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ finance/                     # Endpoints financieros
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ workout/                     # Endpoints de workout
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ai/                          # Endpoints de IA
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ calendar/                    # Endpoints de calendario
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ analytics/                   # Endpoints de analÃ­tica
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ payments/                    # Endpoints de pagos
â”‚   â”‚   â”œâ”€â”€ core/                                # ConfiguraciÃ³n central
â”‚   â”‚   â”œâ”€â”€ db/                                  # Modelos y esquemas
â”‚   â”‚   â”œâ”€â”€ services/                            # LÃ³gica de negocio
â”‚   â”‚   â”‚   â”œâ”€â”€ ai/                              # Servicios de IA
â”‚   â”‚   â”‚   â”œâ”€â”€ calendar/                        # Servicios de calendario
â”‚   â”‚   â”‚   â””â”€â”€ payment/                         # Servicios de pago
â”‚   â”‚   â””â”€â”€ utils/                               # Utilidades
â”œâ”€â”€ supabase/                                     # ConfiguraciÃ³n de Supabase
    â””â”€â”€ migrations/                               # Migraciones SQL


## ImplementaciÃ³n TÃ©cnica Detallada

### 1. Interfaces de Datos Robustas
# Definir interfaces precisas para datos mock y datos de API:
// ğŸ“„ types/data-interfaces.ts

// Interfaz para datos mock de Tareas
export interface TaskMockData {
  id: number;
  title: string;
  dueDate: string; // formato "YYYY-MM-DD"
  priority: 'high' | 'medium' | 'low';
}

// Interfaz para datos de API de Tareas
export interface TaskApiData {
  id: string;
  title: string;
  due_date: string; // formato "YYYY-MM-DD"
  priority: string;
  user_id: string;
  // otros campos
}
### 2. Adaptadores
# Crear adaptadores para transformar entre formatos:
// ğŸ“„ adapters/tasksAdapter.ts
import { TaskApiData, TaskMockData } from '@/types/data-interfaces';

export const tasksAdapter = {
  apiToMockFormat(apiData: TaskApiData[]): TaskMockData[] {
    return apiData.map(task => ({
      id: parseInt(task.id),
      title: task.title,
      dueDate: task.due_date,
      priority: task.priority as 'high' | 'medium' | 'low',
    }));
  }
};
### 3. Servicios de datos
# Implementar servicios para comunicaciÃ³n con Supabase:
// ğŸ“„ services/tasksService.ts
import { supabase } from '@/lib/supabase';
import { TaskApiData } from '@/types/data-interfaces';

export const tasksService = {
  async getTasks(): Promise<TaskApiData[]> {
    const { data, error } = await supabase
      .from('tasks')
      .select('*')
      .order('due_date', { ascending: true });
    
    if (error) throw error;
    return data || [];
  },
  
  async createTask(task: Omit<TaskApiData, 'id' | 'user_id'>): Promise<TaskApiData> {
    const { data, error } = await supabase
      .from('tasks')
      .insert(task)
      .select()
      .single();
    
    if (error) throw error;
    return data;
  },
  
  // Otros mÃ©todos CRUD
};
### 4. Proveedores de datos
# Crear contextos para proporcionar datos a componentes:

// ğŸ“„ providers/TasksDataProvider.tsx
import { ReactNode, createContext, useContext, useEffect, useState } from 'react';
import { useDataSourceStore } from '@/store/dataSourceStore';
import { mockTasks } from '@/data/mockData';
import { tasksService } from '@/services/tasksService';
import { tasksAdapter } from '@/adapters/tasksAdapter';
import { TaskMockData } from '@/types/data-interfaces';

interface TasksDataContextType {
  tasks: TaskMockData[];
  isLoading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
}

const TasksDataContext = createContext<TasksDataContextType | undefined>(undefined);

export function TasksDataProvider({ children }: { children: ReactNode }) {
  const [tasks, setTasks] = useState<TaskMockData[]>(mockTasks);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const { useRealData } = useDataSourceStore();

  const fetchTasks = async () => {
    if (!useRealData) {
      setTasks(mockTasks);
      return;
    }

    setIsLoading(true);
    try {
      const apiData = await tasksService.getTasks();
      const formattedData = tasksAdapter.apiToMockFormat(apiData);
      setTasks(formattedData);
      setError(null);
    } catch (err) {
      setError(err instanceof Error ? err : new Error('Unknown error'));
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    fetchTasks();
  }, [useRealData]);

  return (
    <TasksDataContext.Provider value={{ 
      tasks, 
      isLoading, 
      error,
      refetch: fetchTasks
    }}>
      {children}
    </TasksDataContext.Provider>
  );
}

export const useTasksData = () => {
  const context = useContext(TasksDataContext);
  if (context === undefined) {
    throw new Error('useTasksData must be used within a TasksDataProvider');
  }
  return context;
};
### 5. Estado global para control de fuente de datos
# Implementar un store para controlar quÃ© fuente de datos usar:
// ğŸ“„ store/dataSourceStore.ts
import { create } from 'zustand';
import { persist } from 'zustand/middleware';

interface DataSourceState {
  useRealData: boolean;
  setUseRealData: (value: boolean) => void;
}

export const useDataSourceStore = create<DataSourceState>()(
  persist(
    (set) => ({
      useRealData: process.env.NODE_ENV === 'production', // ProducciÃ³n siempre usa datos reales
      setUseRealData: (value) => set({ useRealData: value }),
    }),
    {
      name: 'data-source-storage',
    }
  )
);

### 6. Toggle para desarrollo
# Crear un componente para alternar fuentes de datos:

// ğŸ“„ components/dev/DataSourceToggle.tsx
import { useDataSourceStore } from '@/store/dataSourceStore';
import { Switch } from '@/components/ui/switch';

export function DataSourceToggle() {
  const { useRealData, setUseRealData } = useDataSourceStore();
  
  // Solo mostrar en desarrollo
  if (process.env.NODE_ENV !== 'development') return null;
  
  return (
    <div className="fixed bottom-4 right-4 bg-white dark:bg-gray-800 p-3 rounded-lg shadow-lg z-50 flex items-center space-x-2">
      <span className={`text-sm ${!useRealData ? 'font-bold' : ''}`}>Mock</span>
      <Switch 
        checked={useRealData} 
        onCheckedChange={setUseRealData} 
      />
      <span className={`text-sm ${useRealData ? 'font-bold' : ''}`}>Real</span>
    </div>
  );
}
### 7. Seeder para datos de demostraciÃ³n
// ğŸ“„ utils/seedDemoData.ts
import { supabase } from '@/lib/supabase';
import { mockTasks, mockGoals, mockHabits } from '@/data/mockData';

export async function seedDemoData() {
  // Obtener el ID del usuario actual
  const { data: { user } } = await supabase.auth.getUser();
  if (!user) throw new Error('Usuario no autenticado');
  
  try {
    // Convertir datos mock a formato de API
    const tasksForApi = mockTasks.map(task => ({
      title: task.title,
      description: task.description || '',
      due_date: task.dueDate,
      priority: task.priority,
      status: 'pending',
      user_id: user.id
    }));
    
    // Insertar tareas
    const { error: tasksError } = await supabase.from('tasks').insert(tasksForApi);
    if (tasksError) throw tasksError;
    
    // Repetir para cada tipo de datos (metas, hÃ¡bitos, etc.)
    
    return { success: true };
  } catch (error) {
    console.error('Error seeding demo data:', error);
    return { success: false, error };
  }
}

### 8. Estados vacÃ­os atractivos
// ğŸ“„ components/ui/EmptyState.tsx
import { Button } from '@/components/ui/button';
import { PlusCircle, ClipboardList, Target, BarChart } from 'lucide-react';
import { seedDemoData } from '@/utils/seedDemoData';
import { useState } from 'react';

type EmptyStateType = 'tasks' | 'goals' | 'habits' | 'finance' | 'workout';

const EmptyStateConfig = {
  tasks: {
    icon: ClipboardList,
    title: 'No tienes tareas pendientes',
    description: 'Crea tu primera tarea para comenzar a organizar tu dÃ­a',
    actionText: 'Crear tarea'
  },
  goals: {
    icon: Target,
    title: 'AÃºn no tienes metas definidas',
    description: 'Establece metas para visualizar tu progreso a largo plazo',
    actionText: 'Definir meta'
  },
  // Configuraciones para otros tipos
};

interface EmptyStateProps {
  type: EmptyStateType;
  onActionClick?: () => void;
  showDemoButton?: boolean;
}

export function EmptyState({ type, onActionClick, showDemoButton = true }: EmptyStateProps) {
  const [isLoading, setIsLoading] = useState(false);
  const config = EmptyStateConfig[type];
  const Icon = config.icon;
  
  const handleDemoData = async () => {
    setIsLoading(true);
    try {
      await seedDemoData();
      // Refrescar datos
    } catch (error) {
      console.error(error);
    } finally {
      setIsLoading(false);
    }
  };
  
  return (
    <div className="flex flex-col items-center justify-center py-12 px-4 text-center bg-gray-50 dark:bg-gray-800/50 rounded-lg border border-dashed border-gray-200 dark:border-gray-700">
      <div className="p-3 bg-primary-100 dark:bg-primary-900/30 rounded-full">
        <Icon className="h-8 w-8 text-primary-500" />
      </div>
      <h3 className="mt-4 text-lg font-medium">{config.title}</h3>
      <p className="mt-2 text-sm text-gray-500 dark:text-gray-400 max-w-sm">
        {config.description}
      </p>
      <div className="mt-6 flex flex-col sm:flex-row gap-3">
        <Button onClick={onActionClick}>
          <PlusCircle className="mr-2 h-4 w-4" />
          {config.actionText}
        </Button>
        
        {showDemoButton && (
          <Button 
            variant="outline" 
            onClick={handleDemoData}
            disabled={isLoading}
          >
            {isLoading ? 'Creando...' : 'Usar datos de ejemplo'}
          </Button>
        )}
      </div>
    </div>
  );
}
### 9. Uso prÃ¡ctico en componentes
// ğŸ“„ components/tasks/TasksList.tsx
import { useTasksData } from '@/providers/TasksDataProvider';
import { TaskCard } from './TaskCard';
import { EmptyState } from '@/components/ui/EmptyState';
import { Skeleton } from '@/components/ui/skeleton';

export function TasksList() {
  const { tasks, isLoading, error } = useTasksData();
  
  // Estado de carga
  if (isLoading) {
    return (
      <div className="space-y-4">
        {Array.from({ length: 3 }).map((_, index) => (
          <Skeleton key={index} className="h-24 w-full rounded-lg" />
        ))}
      </div>
    );
  }
  
  // Estado de error
  if (error) {
    return (
      <div className="p-4 rounded-lg bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800">
        <p className="text-red-600 dark:text-red-400">Error: {error.message}</p>
        <button className="mt-2 text-sm text-red-600 dark:text-red-400 underline">
          Reintentar
        </button>
      </div>
    );
  }
  
  // Estado vacÃ­o
  if (tasks.length === 0) {
    return <EmptyState type="tasks" onActionClick={() => {/* Abrir modal */}} />;
  }
  
  // Renderizado normal
  return (
    <div className="space-y-4">
      {tasks.map(task => (
        <TaskCard key={task.id} task={task} />
      ))}
    </div>
  );
}

# Proceso de migraciÃ³n mÃ³dulo a mÃ³dulo:
Aplicar este proceso para cada mÃ³dulo, en el siguiente orden:
1. Tareas: Funcionalidad bÃ¡sica, buen punto de inicio
2. Metas: Siguiente nivel de complejidad
3. HÃ¡bitos: Incluye funcionalidad de streak/rachas
4. Workout: Componentes mÃ¡s complejos
5. Finanzas: Datos numÃ©ricos y grÃ¡ficos
6. Calendario: IntegraciÃ³n con Google Calendar
7. Asistente IA: Componentes conversacionales
8. AnalÃ­tica: Visualizaciones y dashboards

# Consejos adicionales:
1. Rendimiento: Usa React Query o SWR para manejo eficiente de datos
2. Desarrollo: Implementa un sistema de flags para caracterÃ­sticas en desarrollo
3. Pruebas: AÃ±ade tests visuales para comparar antes/despuÃ©s
4. Despliegue: Usa feature flags para control gradual en producciÃ³n

El enfoque de "adaptadores" es clave para mantener la UI actual mientras migras a datos reales. Este patrÃ³n permite una transiciÃ³n suave y controlada.
