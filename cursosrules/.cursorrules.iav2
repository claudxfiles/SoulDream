Implementación del Asistente IA con Sistema de Metas
Este documento detalla cómo integrar el asistente IA desarrollado en tu aplicación existente, siguiendo la estructura de directorios que has proporcionado.

1. Estructura de Archivos a Crear o Modificar
```
frontend/
├── src/
│   ├── components/
│   │   ├── ai-assistant/               # CREAR DIRECTORIO
│   │   │   ├── AiChatInterface.tsx     # CREAR ARCHIVO
│   │   │   ├── AIAssistant.tsx         # CREAR ARCHIVO
│   │   │   ├── ChatMessage.tsx         # CREAR ARCHIVO
│   │   │   ├── GoalChatIntegration.tsx # CREAR ARCHIVO
│   │   │   ├── PatternAnalyzer.tsx     # CREAR ARCHIVO
│   │   │   ├── LearningAdaptation.tsx  # CREAR ARCHIVO
│   │   │   ├── PersonalizedPlanGenerator.tsx # CREAR ARCHIVO
│   │   │   └── MetaAIPanel.tsx         # CREAR ARCHIVO
│   ├── app/
│   │   ├── dashboard/
│   │   │   └── ai-assistant/
│   │   │       └── page.tsx            # CREAR ARCHIVO
│   ├── hooks/
│   │   └── useAIAssistant.ts           # CREAR ARCHIVO
│   ├── services/
│   │   └── ai.ts                       # CREAR O MODIFICAR ARCHIVO
```

Backend (integración con tu API):
```
backend/
├── app/
│   ├── api/
│   │   ├── v1/
│   │   │   ├── ai/
│   │   │   │   ├── chat.ts             # MODIFICAR O CREAR
│   │   │   │   ├── goals.ts            # MODIFICAR O CREAR
│   │   │   │   └── patterns.ts         # MODIFICAR O CREAR
│   ├── services/
│   │   ├── ai/
│   │   │   ├── assistant.ts            # MODIFICAR O CREAR
│   │   │   ├── patternAnalysis.ts      # MODIFICAR O CREAR
│   │   │   └── goalsIntegration.ts     # MODIFICAR O CREAR
```
2. Pasos de Implementación
Paso 1: Preparar el Entorno Frontend
Asegúrate de tener las dependencias necesarias:
```
cd frontend
bun add date-fns zustand
```

Organiza la estructura de directorios:
```
mkdir -p src/components/ai-assistant
mkdir -p src/app/dashboard/ai-assistant
```

Paso 2: Implementar el Hook Principal
El hook useAIAssistant es el corazón de la funcionalidad del asistente IA, gestionando el estado y la lógica:
1. Crea el archivo src/hooks/useAIAssistant.ts:
```
"use client";

import { useState, useCallback } from 'react';
// Importa el servicio de IA que implementarás
import { getAIResponse, analyzePatterns, generatePlan } from '@/services/ai';
// Si usas Zustand para estado global, importa tu store
import { useGoalStore } from '@/store/goalStore';

// Define tipos para mensajes y contexto AI
export type MessageRole = 'user' | 'assistant' | 'system';

export interface Message {
  id: string;
  content: string;
  role: MessageRole;
  timestamp: Date;
}

export interface Goal {
  id: string;
  title: string;
  description: string;
  status: 'pending' | 'in-progress' | 'completed';
  createdAt: Date;
  dueDate?: Date;
}

export interface Task {
  id: string;
  goalId: string;
  title: string;
  description?: string;
  status: 'pending' | 'in-progress' | 'completed';
  createdAt: Date;
  dueDate?: Date;
}

export interface AIContext {
  goals: Goal[];
  tasks: Task[];
  learningPreferences: string[];
  userProfile?: {
    name?: string;
    interests?: string[];
    strengths?: string[];
    weaknesses?: string[];
  };
}

// Helper para generar IDs
const generateId = () => {
  return Math.random().toString(36).substring(2, 15) + 
         Math.random().toString(36).substring(2, 15);
};

export const useAIAssistant = () => {
  // Si ya tienes un store global para metas/tareas, usa ese
  // const { goals, tasks, addGoal, addTask, updateGoal, updateTask, deleteGoal, deleteTask } = useGoalStore();

  // Estado local en caso de no usar estado global
  const [messages, setMessages] = useState<Message[]>([
    {
      id: generateId(),
      content: 'Hola! Soy tu asistente IA. Puedo ayudarte a establecer metas y tareas, analizar patrones en tu comportamiento, y crear planes personalizados. ¿En qué puedo ayudarte hoy?',
      role: 'assistant',
      timestamp: new Date(),
    },
  ]);
  
  const [isProcessing, setIsProcessing] = useState(false);
  const [context, setContext] = useState<AIContext>({
    goals: [],
    tasks: [],
    learningPreferences: [],
  });

  // Función para añadir un mensaje del usuario
  const addUserMessage = useCallback(async (content: string) => {
    if (!content.trim()) return;
    
    const userMessage: Message = {
      id: generateId(),
      content,
      role: 'user',
      timestamp: new Date(),
    };
    
    setMessages(prev => [...prev, userMessage]);
    setIsProcessing(true);
    
    try {
      // Obtener respuesta de IA - aquí se implementaría la llamada a tu API
      const response = await getAIResponse(content, messages, context);
      
      // Analizar mensaje para potenciales metas o tareas
      const updatedContext = analyzeUserMessage(content, context);
      setContext(updatedContext);
      
      // Añadir respuesta del asistente
      const assistantMessage: Message = {
        id: generateId(),
        content: response,
        role: 'assistant',
        timestamp: new Date(),
      };
      
      setMessages(prev => [...prev, assistantMessage]);
    } catch (error) {
      console.error('Error procesando mensaje:', error);
      
      // Añadir mensaje de error
      const errorMessage: Message = {
        id: generateId(),
        content: 'Lo siento, encontré un error procesando tu solicitud. Por favor, inténtalo de nuevo.',
        role: 'assistant',
        timestamp: new Date(),
      };
      
      setMessages(prev => [...prev, errorMessage]);
    } finally {
      setIsProcessing(false);
    }
  }, [messages, context]);

  // Función para analizar mensajes del usuario para potenciales metas y tareas
  const analyzeUserMessage = (message: string, currentContext: AIContext): AIContext => {
    const lowerMessage = message.toLowerCase();
    const newContext = { ...currentContext };
    
    // Ejemplo de análisis básico para metas/tareas (en implementación real sería más sofisticado)
    if (lowerMessage.includes('meta') && (lowerMessage.includes('crear') || lowerMessage.includes('nueva'))) {
      // Extraer potencial título de meta - implementación simple
      const goalTitle = message.replace(/crear una meta/i, '').trim();
      
      if (goalTitle) {
        const newGoal: Goal = {
          id: generateId(),
          title: goalTitle.slice(0, 1).toUpperCase() + goalTitle.slice(1),
          description: 'Auto-generado basado en la conversación',
          status: 'pending',
          createdAt: new Date(),
        };
        
        newContext.goals = [...newContext.goals, newGoal];
      }
    }
    
    if (lowerMessage.includes('tarea') && lowerMessage.includes('añadir') && newContext.goals.length > 0) {
      // Extracción simple de tarea - implementación básica
      const taskTitle = message.replace(/añadir una tarea/i, '').trim();
      
      if (taskTitle) {
        const newTask: Task = {
          id: generateId(),
          goalId: newContext.goals[newContext.goals.length - 1].id, // Añadir a la meta más reciente
          title: taskTitle.slice(0, 1).toUpperCase() + taskTitle.slice(1),
          status: 'pending',
          createdAt: new Date(),
        };
        
        newContext.tasks = [...newContext.tasks, newTask];
      }
    }
    
    return newContext;
  };

  // Funciones para gestionar metas y tareas manualmente
  const addGoal = useCallback((title: string, description: string) => {
    const newGoal: Goal = {
      id: generateId(),
      title,
      description,
      status: 'pending',
      createdAt: new Date(),
    };
    
    setContext(prev => ({
      ...prev,
      goals: [...prev.goals, newGoal],
    }));
    
    return newGoal;
  }, []);

  const addTask = useCallback((goalId: string, title: string, description?: string) => {
    const newTask: Task = {
      id: generateId(),
      goalId,
      title,
      description,
      status: 'pending',
      createdAt: new Date(),
    };
    
    setContext(prev => ({
      ...prev,
      tasks: [...prev.tasks, newTask],
    }));
    
    return newTask;
  }, []);

  const updateGoal = useCallback((goalId: string, updates: Partial<Goal>) => {
    setContext(prev => ({
      ...prev,
      goals: prev.goals.map(goal => 
        goal.id === goalId ? { ...goal, ...updates } : goal
      ),
    }));
  }, []);

  const updateTask = useCallback((taskId: string, updates: Partial<Task>) => {
    setContext(prev => ({
      ...prev,
      tasks: prev.tasks.map(task => 
        task.id === taskId ? { ...task, ...updates } : task
      ),
    }));
  }, []);

  const deleteGoal = useCallback((goalId: string) => {
    setContext(prev => ({
      ...prev,
      goals: prev.goals.filter(goal => goal.id !== goalId),
      // También eliminar tareas asociadas
      tasks: prev.tasks.filter(task => task.goalId !== goalId),
    }));
  }, []);

  const deleteTask = useCallback((taskId: string) => {
    setContext(prev => ({
      ...prev,
      tasks: prev.tasks.filter(task => task.id !== taskId),
    }));
  }, []);

  // Función para generar un plan personalizado
  const generatePersonalizedPlan = useCallback(async () => {
    try {
      // En implementación real, esta sería una llamada a tu API
      const { goal, tasks } = await generatePlan(context);
      
      // Añadir meta y tareas al contexto
      setContext(prev => ({
        ...prev,
        goals: [...prev.goals, goal],
        tasks: [...prev.tasks, ...tasks],
      }));
      
      return goal;
    } catch (error) {
      console.error('Error generando plan:', error);
      return null;
    }
  }, [context]);

  return {
    messages,
    isProcessing,
    context,
    addUserMessage,
    addGoal,
    addTask,
    updateGoal,
    updateTask,
    deleteGoal,
    deleteTask,
    generatePersonalizedPlan,
  };
};
```
Paso 3: Implementar los Servicios de IA
Crea el archivo src/services/ai.ts para gestionar las comunicaciones con tu backend:
```
import { Message, AIContext, Goal, Task } from '@/hooks/useAIAssistant';

// Endpoint base para las llamadas a la API
const API_BASE_URL = '/api/v1/ai';

// Función para enviar mensaje al asistente IA
export async function getAIResponse(
  message: string,
  history: Message[],
  context: AIContext
): Promise<string> {
  try {
    const response = await fetch(`${API_BASE_URL}/chat`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        message,
        history: history.map(msg => ({
          role: msg.role,
          content: msg.content,
        })),
        context: {
          goals: context.goals,
          tasks: context.tasks,
          learningPreferences: context.learningPreferences,
          userProfile: context.userProfile,
        },
      }),
    });

    if (!response.ok) {
      throw new Error('Error en la llamada a la API');
    }

    const data = await response.json();
    return data.response;
  } catch (error) {
    console.error('Error en la llamada a la API:', error);
    return "Lo siento, tuve un problema conectándome al servicio. Por favor, inténtalo de nuevo.";
  }
}

// Función para analizar patrones del usuario
export async function analyzePatterns(
  messages: Message[],
  context: AIContext
): Promise<string[]> {
  try {
    const response = await fetch(`${API_BASE_URL}/patterns`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        messages: messages.map(msg => ({
          role: msg.role,
          content: msg.content,
        })),
        context,
      }),
    });

    if (!response.ok) {
      throw new Error('Error analizando patrones');
    }

    const data = await response.json();
    return data.patterns;
  } catch (error) {
    console.error('Error analizando patrones:', error);
    return [
      'El usuario tiende a ser más productivo por la mañana',
      'El usuario responde bien a dividir tareas grandes en pasos más pequeños',
      'El usuario es más propenso a completar tareas con fechas límite claras',
    ];
  }
}

// Función para generar un plan personalizado
export async function generatePlan(context: AIContext): Promise<{
  goal: Goal;
  tasks: Task[];
}> {
  try {
    const response = await fetch(`${API_BASE_URL}/goals/generate-plan`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ context }),
    });

    if (!response.ok) {
      throw new Error('Error generando plan');
    }

    return await response.json();
  } catch (error) {
    console.error('Error generando plan:', error);
    
    // Devolver plan por defecto en caso de error
    const goal: Goal = {
      id: Math.random().toString(36).substr(2, 9),
      title: 'Aumentar Productividad',
      description: 'Enfocarse en mejorar la producción diaria y la satisfacción laboral',
      status: 'pending',
      createdAt: new Date(),
      dueDate: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 días desde ahora
    };
    
    const tasks: Task[] = [
      {
        id: Math.random().toString(36).substr(2, 9),
        goalId: goal.id,
        title: 'Implementar técnica de bloques de tiempo',
        description: 'Programar bloques específicos de tiempo para diferentes tipos de trabajo',
        status: 'pending',
        createdAt: new Date(),
        dueDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 días desde ahora
      },
      {
        id: Math.random().toString(36).substr(2, 9),
        goalId: goal.id,
        title: 'Crear espacio de trabajo libre de distracciones',
        description: 'Organizar escritorio y minimizar distracciones digitales',
        status: 'pending',
        createdAt: new Date(),
        dueDate: new Date(Date.now() + 3 * 24 * 60 * 60 * 1000), // 3 días desde ahora
      },
      {
        id: Math.random().toString(36).substr(2, 9),
        goalId: goal.id,
        title: 'Probar diferentes ratios de trabajo-descanso',
        description: 'Experimentar con Pomodoro y otras técnicas',
        status: 'pending',
        createdAt: new Date(),
        dueDate: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), // 14 días desde ahora
      },
    ];
    
    return { goal, tasks };
  }
}
```

Paso 4: Implementar los Componentes de UI
1. Componente ChatMessage:
```
"use client";

import { Avatar } from '@/components/ui/avatar';
import { cn } from '@/lib/utils';
import { Message } from '@/hooks/useAIAssistant';
import { format } from 'date-fns';

interface ChatMessageProps {
  message: Message;
}

export function ChatMessage({ message }: ChatMessageProps) {
  const isUser = message.role === 'user';
  
  return (
    <div
      className={cn(
        'flex w-full gap-3 p-4',
        isUser ? 'bg-muted/50' : 'bg-background'
      )}
    >
      <Avatar className={cn(
        'h-8 w-8',
        isUser ? 'bg-primary' : 'bg-blue-500'
      )}>
        <span className="text-xs font-medium text-white">
          {isUser ? 'U' : 'AI'}
        </span>
      </Avatar>
      
      <div className="flex-1 space-y-2">
        <div className="flex items-center gap-2">
          <span className="text-sm font-medium">
            {isUser ? 'Tú' : 'Asistente'}
          </span>
          <span className="text-xs text-muted-foreground">
            {format(new Date(message.timestamp), 'h:mm a')}
          </span>
        </div>
        
        <div className="text-sm leading-relaxed">
          {message.content.split('\n').map((text, i) => (
            <p key={`${message.id}-line-${i}`} className={i > 0 ? 'mt-4' : ''}>
              {text}
            </p>
          ))}
        </div>
      </div>
    </div>
  );
}
```

2. Componente GoalChatIntegration:
```
"use client";

import { useState } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Separator } from '@/components/ui/separator';
import { Goal, Task } from '@/hooks/useAIAssistant';
import { format } from 'date-fns';

interface GoalChatIntegrationProps {
  goals: Goal[];
  tasks: Task[];
  onUpdateGoal: (goalId: string, updates: Partial<Goal>) => void;
  onUpdateTask: (taskId: string, updates: Partial<Task>) => void;
  onDeleteGoal: (goalId: string) => void;
  onDeleteTask: (taskId: string) => void;
}

export function GoalChatIntegration({
  goals,
  tasks,
  onUpdateGoal,
  onUpdateTask,
  onDeleteGoal,
  onDeleteTask,
}: GoalChatIntegrationProps) {
  const [expandedGoalId, setExpandedGoalId] = useState<string | null>(null);
  
  // Toggle goal expansion
  const toggleGoalExpansion = (goalId: string) => {
    setExpandedGoalId(expandedGoalId === goalId ? null : goalId);
  };
  
  // Toggle task status
  const toggleTaskStatus = (taskId: string, currentStatus: string) => {
    const newStatus = currentStatus === 'completed' ? 'pending' : 'completed';
    onUpdateTask(taskId, { status: newStatus as 'pending' | 'completed' | 'in-progress' });
  };
  
  // Mark goal as complete
  const completeGoal = (goalId: string) => {
    onUpdateGoal(goalId, { status: 'completed' });
  };
  
  if (goals.length === 0) {
    return (
      <Card className="border border-gray-200 shadow-sm">
        <CardContent className="p-6 text-center">
          <p className="text-sm text-muted-foreground">
            No hay metas aún. Pide al asistente IA que te ayude a crear metas y tareas.
          </p>
        </CardContent>
      </Card>
    );
  }
  
  return (
    <div className="space-y-4">
      {goals.map((goal) => {
        const goalTasks = tasks.filter((task) => task.goalId === goal.id);
        const isExpanded = expandedGoalId === goal.id;
        const completedTaskCount = goalTasks.filter((task) => task.status === 'completed').length;
        const progress = goalTasks.length > 0 
          ? Math.round((completedTaskCount / goalTasks.length) * 100) 
          : 0;
        
        return (
          <Card 
            key={goal.id} 
            className={`border ${goal.status === 'completed' ? 'border-green-200 bg-green-50' : 'border-gray-200'}`}
          >
            <CardHeader className="pb-2">
              <div className="flex items-start justify-between">
                <CardTitle 
                  className={`text-sm font-medium ${goal.status === 'completed' ? 'text-green-700' : ''}`}
                >
                  {goal.title}
                </CardTitle>
                <div className="flex items-center gap-1">
                  {goal.status !== 'completed' && (
                    <Button
                      variant="outline"
                      size="sm"
                      className="h-6 w-6 p-0 text-green-600"
                      onClick={() => completeGoal(goal.id)}
                    >
                      <svg
                        xmlns="http://www.w3.org/2000/svg"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        className="h-3 w-3"
                      >
                        <polyline points="20 6 9 17 4 12" />
                      </svg>
                      <span className="sr-only">Completar</span>
                    </Button>
                  )}
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-6 w-6 p-0 text-red-600"
                    onClick={() => onDeleteGoal(goal.id)}
                  >
                    <svg
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="h-3 w-3"
                    >
                      <path d="M3 6h18" />
                      <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                      <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                    </svg>
                    <span className="sr-only">Eliminar</span>
                  </Button>
                </div>
              </div>
              <p className="mt-1 text-xs text-muted-foreground">{goal.description}</p>
            </CardHeader>
            
            <CardContent className="pb-4">
              {/* Barra de progreso */}
              <div className="mb-2">
                <div className="flex items-center justify-between text-xs">
                  <span>{completedTaskCount} de {goalTasks.length} tareas completadas</span>
                  <span>{progress}%</span>
                </div>
                <div className="mt-1 h-1.5 w-full rounded-full bg-gray-100">
                  <div 
                    className="h-1.5 rounded-full bg-blue-500" 
                    style={{ width: `${progress}%` }}
                  />
                </div>
              </div>
              
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-2">
                  <span className="text-xs text-muted-foreground">
                    Creado: {format(new Date(goal.createdAt), 'dd/MM/yyyy')}
                  </span>
                  {goal.dueDate && (
                    <span className="text-xs text-muted-foreground">
                      Vence: {format(new Date(goal.dueDate), 'dd/MM/yyyy')}
                    </span>
                  )}
                </div>
                
                <Button
                  variant="ghost"
                  size="sm"
                  className="h-7 px-2 text-xs"
                  onClick={() => toggleGoalExpansion(goal.id)}
                >
                  {isExpanded ? 'Ocultar Tareas' : 'Mostrar Tareas'}
                  <svg
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className={`ml-1 h-3 w-3 transition-transform ${isExpanded ? 'rotate-180' : ''}`}
                  >
                    <polyline points="6 9 12 15 18 9" />
                  </svg>
                </Button>
              </div>
              
              {isExpanded && (
                <div className="mt-4 space-y-3">
                  <Separator />
                  
                  {goalTasks.length > 0 ? (
                    <ul className="space-y-2">
                      {goalTasks.map((task) => (
                        <li key={task.id} className="flex items-start justify-between gap-3 text-sm">
                          <div className="flex items-start gap-2">
                            <button
                              className={`mt-0.5 h-4 w-4 rounded-full border ${
                                task.status === 'completed' 
                                  ? 'border-green-500 bg-green-500' 
                                  : 'border-gray-300'
                              }`}
                              onClick={() => toggleTaskStatus(task.id, task.status)}
                            >
                              {task.status === 'completed' && (
                                <svg
                                  xmlns="http://www.w3.org/2000/svg"
                                  viewBox="0 0 24 24"
                                  fill="none"
                                  stroke="white"
                                  strokeWidth="2"
                                  strokeLinecap="round"
                                  strokeLinejoin="round"
                                  className="h-3 w-3"
                                >
                                  <polyline points="20 6 9 17 4 12" />
                                </svg>
                              )}
                              <span className="sr-only">Toggle estado de la tarea</span>
                            </button>
                            <div>
                              <p className={task.status === 'completed' ? 'line-through text-muted-foreground' : ''}>
                                {task.title}
                              </p>
                              {task.description && (
                                <p className="mt-0.5 text-xs text-muted-foreground">
                                  {task.description}
                                </p>
                              )}
                            </div>
                          </div>
                          
                          <Button
                            variant="ghost"
                            size="sm"
                            className="h-6 w-6 p-0 text-red-600"
                            onClick={() => onDeleteTask(task.id)}
                          >
                            <svg
                              xmlns="http://www.w3.org/2000/svg"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                              className="h-3 w-3"
                            >
                              <path d="M3 6h18" />
                              <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6" />
                              <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2" />
                            </svg>
                            <span className="sr-only">Eliminar</span>
                          </Button>
                        </li>
                      ))}
                    </ul>
                  ) : (
                    <p className="py-2 text-xs text-muted-foreground">
                      No hay tareas aún. Pide al asistente IA que te ayude a crear tareas para esta meta.
                    </p>
                  )}
                </div>
              )}
            </CardContent>
          </Card>
        );
      })}
    </div>
  );
}
```

3. Componente AIAssistant:
```
"use client";

import { useRef, useState } from 'react';
import { useAIAssistant } from '@/hooks/useAIAssistant';
import { ChatMessage } from './ChatMessage';
import { PatternAnalyzer } from './PatternAnalyzer';
import { LearningAdaptation } from './LearningAdaptation';
import { PersonalizedPlanGenerator } from './PersonalizedPlanGenerator';

import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Separator } from '@/components/ui/separator';

export function AIAssistant() {
  const {
    messages,
    isProcessing,
    context,
    addUserMessage,
    addGoal,
    addTask,
    updateGoal,
    updateTask,
    deleteGoal,
    deleteTask,
    generatePersonalizedPlan,
  } = useAIAssistant();

  const [inputValue, setInputValue] = useState('');
  const messagesEndRef = useRef<HTMLDivElement>(null);

  // Scroll to bottom when messages change
  const scrollToBottom = () => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
  };

  // Handle form submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();

    if (!inputValue.trim() || isProcessing) return;

    const message = inputValue;
    setInputValue('');

    await addUserMessage(message);
    scrollToBottom();
  };

  // Update learning preferences
  const handleUpdatePreferences = (preferences: string[]) => {
    // In a real implementation, this would update the context in the database
    console.log('Updated preferences:', preferences);
  };

  return (
    <div className="flex h-full flex-col overflow-hidden rounded-lg border bg-background shadow">
      <CardHeader className="px-4 py-3 sm:px-6">
        <div className="flex items-center justify-between">
          <CardTitle className="text-base font-medium">AI Assistant</CardTitle>
          <div className="flex items-center gap-2">
            <Button variant="ghost" size="sm" className="h-8 text-xs">
              <svg
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="mr-1 h-4 w-4"
              >
                <path d="M21 12a9 9 0 0 0-9-9 9 9 0 0 0-9 9 9 9 0 0 0 9 9 9 9 0 0 0 9-9Z" />
                <path d="M9 12h6" />
                <path d="M12 9v6" />
              </svg>
              New Chat
            </Button>
          </div>
        </div>
      </CardHeader>

      <Separator />

      <div className="flex-1 overflow-auto p-1">
        <div className="space-y-px">
          {messages.map((message) => (
            <ChatMessage key={message.id} message={message} />
          ))}

          {isProcessing && (
            <div className="flex w-full gap-3 bg-background p-4">
              <div className="h-8 w-8 rounded-full bg-blue-500 flex items-center justify-center">
                <span className="text-xs text-white">AI</span>
              </div>
              <div className="flex-1 space-y-2">
                <div className="flex items-center gap-2">
                  <span className="text-sm font-medium">Assistant</span>
                </div>
                <div className="flex space-x-1">
                  <div className="h-2 w-2 rounded-full bg-blue-400 animate-pulse" />
                  <div className="h-2 w-2 rounded-full bg-blue-400 animate-pulse delay-75" />
                  <div className="h-2 w-2 rounded-full bg-blue-400 animate-pulse delay-150" />
                </div>
              </div>
            </div>
          )}

          <div ref={messagesEndRef} />
        </div>
      </div>

      <div className="p-3 sm:p-4">
        <div className="mb-3 flex items-center justify-center">
          <LearningAdaptation
            context={context}
            onUpdatePreferences={handleUpdatePreferences}
          />
        </div>

        <form onSubmit={handleSubmit} className="flex gap-2">
          <Input
            className="flex-1"
            placeholder="Type your message..."
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            disabled={isProcessing}
          />
          <Button
            type="submit"
            variant="default"
            disabled={isProcessing || !inputValue.trim()}
          >
            <span className="sr-only">Send</span>
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
              className="h-4 w-4"
            >
              <path d="m22 2-7 20-4-9-9-4Z" />
              <path d="M22 2 11 13" />
            </svg>
          </Button>
        </form>
      </div>
    </div>
  );
}
```






